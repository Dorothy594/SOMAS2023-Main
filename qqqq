[1mdiff --git a/internal/clients/team1/agent.go b/internal/clients/team1/agent.go[m
[1mindex 05e834b..0dc2ac2 100644[m
[1m--- a/internal/clients/team1/agent.go[m
[1m+++ b/internal/clients/team1/agent.go[m
[36m@@ -14,23 +14,23 @@[m [mimport ([m
 // agent specific parameters[m
 const deviateNegative = 0.1          // trust loss on deviation[m
 const deviatePositive = 0.15         // trust gain on non deviation[m
[31m-const effortScaling = 0.1            // scaling factor for effort, highr it is the more effort chages each round[m
[32m+[m[32mconst effortScaling = 0.2            // scaling factor for effort, highr it is the more effort chages each round[m
 const fairnessScaling = 0.1          // scaling factor for fairness, higher it is the more fairness changes each round[m
 const relativeSuccessScaling = 0.1   // scaling factor for relative success, higher it is the more relative success changes each round[m
 const votingAlignmentThreshold = 0.6 // threshold for voting alignment[m
[31m-const leaveThreshold = 0.0           // threshold for leaving[m
[31m-const kickThreshold = 0.0            // threshold for kicking[m
[31m-const trustThreshold = 0.7           // threshold for trusting (need to tune)[m
[31m-const fairnessConstant = 0.5         // weight of fairness in opinion[m
[31m-const joinThreshold = -0.2           // opinion threshold for joining if not same colour[m
[32m+[m[32mconst leaveThreshold = 0.1           // threshold for leaving[m
[32m+[m[32mconst kickThreshold = 0.1            // threshold for kicking[m
[32m+[m[32mconst trustThreshold = 0.7           // threshold for trusting (need to tune) MINIMUM AMOUNT OF TRUST TO ACCEPT A MESSAGE[m
[32m+[m[32mconst fairnessConstant = 1           // weight of fairness in opinion[m
[32m+[m[32mconst joinReputationThreshold = 0.3  // opinion threshold for joining if not same colour[m
 const leaderThreshold = 0.95         // opinion threshold for becoming leader[m
 const trustconstant = 1              // weight of trust in opinion[m
 const effortConstant = 1             // weight of effort in opinion[m
 const fairnessDifference = 0.5       // modifies how much fairness increases of decreases, higher is more increase, 0.5 is fair[m
 const lowEnergyLevel = 0.3           // energy level below which the agent will try to get a lootbox of the desired colour[m
[31m-const leavingThreshold = 0.3         // how low the agent's vote must be to leave bike[m
 const colorOpinionConstant = 0.2     // how much any agent likes any other of the same colour in the objective function[m
 const audiDistanceThreshold = 75     // how close the agent must be to the audi to run away[m
[32m+[m[32mconst reputationScaling = 0.1        //scaling factor for effort, the higher it is the more other agents' opinion influences ours[m
 [m
 // Governance decision constants[m
 const democracyOpinonThreshold = 0.5[m
[36m@@ -77,7 +77,6 @@[m [mfunc (bb *Biker1) GetLocation() utils.Coordinates {[m
 	megaBikes := gs.GetMegaBikes()[m
 	position := megaBikes[bikeId].GetPosition()[m
 	if math.IsNaN(position.X) {[m
[31m-		// fmt.Printf("agent %v has no position\n", bb.GetID())[m
 	}[m
 	return position[m
 }[m
[36m@@ -118,10 +117,16 @@[m [mfunc (bb *Biker1) PickBestBike() uuid.UUID {[m
 		}[m
 	}[m
 	if len(scoreMap) == 0 {[m
[31m-		return bb.mostRecentBike[m
[32m+[m		[32m//if tried all bikes, reset[m
[32m+[m		[32mbb.pursuedBikes = make([]uuid.UUID, 0)[m
[32m+[m		[32mfor _, bike := range allBikes {[m
[32m+[m			[32mif len(bike.GetAgents()) < utils.BikersOnBike || bike.GetID() == bb.mostRecentBike {[m
[32m+[m				[32mscoreMap[bike.GetID()] = bb.ScoreBike(bike)[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
 	}[m
[31m-	bestBike := bb.GetBike()[m
[31m-	bestScore := scoreMap[bestBike][m
[32m+[m	[32mbestBike := uuid.Nil[m
[32m+[m	[32mbestScore := 0.0[m
 	for id, score := range scoreMap {[m
 		if score > bestScore {[m
 			bestBike = id[m
[36m@@ -142,12 +147,16 @@[m [mfunc (bb *Biker1) updatePrevEnergy() {[m
 func (bb *Biker1) DecideAction() obj.BikerAction {[m
 	bb.mostRecentBike = bb.GetBike()[m
 	fellowBikers := bb.GetFellowBikers()[m
[31m-[m
 	// Update opinion metrics[m
[31m-	if bb.recentDecided != uuid.Nil {[m
[32m+[m	[32mbb.DetermineOurAverageReputation()[m
[32m+[m	[32mif bb.recentDecided != uuid.Nil && fellowBikers != nil {[m
 		bb.UpdateAllAgentsTrust(fellowBikers)[m
[31m-		// bb.UpdateAllAgentsEffort()[m
 		bb.UpdateAllAgentsOpinions(fellowBikers)[m
[32m+[m		[32m// bb.UpdateAllAgentsRelativeSuccess(fellowBikers)[m
[32m+[m
[32m+[m		[32mif bb.getPedalForce() > 0 && bb.GetEnergyLevel() < bb.prevEnergy[bb.GetID()] {[m
[32m+[m			[32mbb.UpdateAllAgentsEffort()[m
[32m+[m		[32m}[m
 	}[m
 [m
 	// update only after receiving a lootbox[m
[36m@@ -170,6 +179,7 @@[m [mfunc (bb *Biker1) DecideAction() obj.BikerAction {[m
 			bb.dislikeVote = false[m
 			newBike := bb.PickBestBike()[m
 			if newBike != bb.GetBike() {[m
[32m+[m				[32mbb.desiredBike = newBike[m
 				// refresh prevEnergy Map[m
 				bb.desiredBike = newBike[m
 				bb.prevEnergy = make(map[uuid.UUID]float64)[m
[36m@@ -184,6 +194,7 @@[m [mfunc (bb *Biker1) DecideAction() obj.BikerAction {[m
 		}[m
 [m
 	} else {[m
[32m+[m		[32mbb.updatePrevEnergy()[m
 		return 0[m
 	}[m
 }[m
[36m@@ -236,9 +247,21 @@[m [mfunc (bb *Biker1) DecideJoining(pendingAgents []uuid.UUID) map[uuid.UUID]bool {[m
 [m
 	decision := make(map[uuid.UUID]bool)[m
 [m
[32m+[m	[32maverageBikeOpinion := 0.0[m
[32m+[m	[32mfor _, agent := range bb.GetFellowBikers() {[m
[32m+[m		[32maverageBikeOpinion += bb.opinions[agent.GetID()].opinion[m
[32m+[m	[32m}[m
[32m+[m
 	for _, agentId := range pendingAgents {[m
 		//TODO FIX[m
 		agent := bb.GetAgentFromId(agentId)[m
[32m+[m		[32mreputation, ok := bb.GetReputation()[agentId][m
[32m+[m		[32mvar agent_reputation float64[m
[32m+[m		[32mif !ok {[m
[32m+[m			[32magent_reputation = 0[m
[32m+[m		[32m} else {[m
[32m+[m			[32magent_reputation = reputation[m
[32m+[m		[32m}[m
 [m
 		bbColour := bb.GetColour()[m
 		agentColour := agent.GetColour()[m
[36m@@ -247,7 +270,7 @@[m [mfunc (bb *Biker1) DecideJoining(pendingAgents []uuid.UUID) map[uuid.UUID]bool {[m
 			sameColourReward := 1.05[m
 			bb.UpdateOpinion(agentId, sameColourReward)[m
 		} else {[m
[31m-			if bb.opinions[agentId].opinion > joinThreshold {[m
[32m+[m			[32mif bb.opinions[agentId].opinion >= averageBikeOpinion || agent_reputation > joinReputationThreshold {[m
 				decision[agentId] = true[m
 				// penalise for accepting them without same colour[m
 				penalty := 0.9[m
[36m@@ -256,7 +279,6 @@[m [mfunc (bb *Biker1) DecideJoining(pendingAgents []uuid.UUID) map[uuid.UUID]bool {[m
 				decision[agentId] = false[m
 			}[m
 		}[m
[31m-		bb.UpdateRelativeSuccess(agentId)[m
 [m
 	}[m
 [m
[36m@@ -307,7 +329,6 @@[m [mfunc (bb *Biker1) VoteForKickout() map[uuid.UUID]int {[m
 [m
 // -------------------INSTANTIATION FUNCTIONS----------------------------[m
 func GetBiker1(baseBiker *obj.BaseBiker) obj.IBaseBiker {[m
[31m-	// fmt.Printf("Creating Biker1 with id %v\n", baseBiker.GetID())[m
 	baseBiker.GroupID = 1[m
 	return &Biker1{[m
 		BaseBiker:      baseBiker,[m
[1mdiff --git a/internal/clients/team1/government.go b/internal/clients/team1/government.go[m
[1mindex f85143e..28ea2ab 100644[m
[1m--- a/internal/clients/team1/government.go[m
[1m+++ b/internal/clients/team1/government.go[m
[36m@@ -27,7 +27,7 @@[m [mfunc (bb *Biker1) DecideGovernance() utils.Governance {[m
 func (bb *Biker1) DecideDemocracy() bool {[m
 	founding_agents := bb.GetAllAgents()[m
 	totalOpinion := 0.0[m
[31m-	reputation := bb.DetermineOurReputation()[m
[32m+[m	[32mreputation := bb.DetermineOurAverageReputation()[m
 	for _, agent := range founding_agents {[m
 		opinion, ok := bb.opinions[agent.GetID()][m
 		if ok {[m
[36m@@ -45,7 +45,7 @@[m [mfunc (bb *Biker1) DecideDemocracy() bool {[m
 func (bb *Biker1) DecideLeadership() bool {[m
 	founding_agents := bb.GetAllAgents()[m
 	totalOpinion := 0.0[m
[31m-	reputation := bb.DetermineOurReputation()[m
[32m+[m	[32mreputation := bb.DetermineOurAverageReputation()[m
 	for _, agent := range founding_agents {[m
 		opinion, ok := bb.opinions[agent.GetID()][m
 		if ok {[m
[36m@@ -63,7 +63,7 @@[m [mfunc (bb *Biker1) DecideLeadership() bool {[m
 func (bb *Biker1) DecideDictatorship() bool {[m
 	founding_agents := bb.GetAllAgents()[m
 	totalOpinion := 0.0[m
[31m-	reputation := bb.DetermineOurReputation()[m
[32m+[m	[32mreputation := bb.DetermineOurAverageReputation()[m
 	for _, agent := range founding_agents {[m
 		opinion, ok := bb.opinions[agent.GetID()][m
 		if ok {[m
[1mdiff --git a/internal/clients/team1/helpers.go b/internal/clients/team1/helpers.go[m
[1mindex b20c9e4..23aa25d 100644[m
[1m--- a/internal/clients/team1/helpers.go[m
[1m+++ b/internal/clients/team1/helpers.go[m
[36m@@ -18,7 +18,12 @@[m [mfunc (bb *Biker1) ComputeDistance(a utils.Coordinates, b utils.Coordinates) floa[m
 func (bb *Biker1) GetFellowBikers() []obj.IBaseBiker {[m
 	gs := bb.GetGameState()[m
 	bikeId := bb.GetBike()[m
[31m-	return gs.GetMegaBikes()[bikeId].GetAgents()[m
[32m+[m	[32mresult, ok := gs.GetMegaBikes()[bikeId][m
[32m+[m	[32mif ok {[m
[32m+[m		[32mreturn result.GetAgents()[m
[32m+[m	[32m} else {[m
[32m+[m		[32mreturn []obj.IBaseBiker{}[m
[32m+[m	[32m}[m
 }[m
 [m
 func (bb *Biker1) GetBikeInstance() obj.IMegaBike {[m
[36m@@ -74,8 +79,8 @@[m [mfunc (bb *Biker1) GetAverageOpinionOfBike(megabike obj.IMegaBike) float64 {[m
 [m
 // -------------------END OF SETTERS AND GETTERS----------------------[m
 [m
[31m-func (bb *Biker1) DistanceFromAudi(obj.IMegaBike) float64 {[m
[31m-	return bb.ComputeDistance(bb.GetLocation(), bb.GetGameState().GetAudi().GetPosition())[m
[32m+[m[32mfunc (bb *Biker1) DistanceFromAudi(bike obj.IMegaBike) float64 {[m
[32m+[m	[32mreturn bb.ComputeDistance(bike.GetPosition(), bb.GetGameState().GetAudi().GetPosition())[m
 }[m
 [m
 // Find an agent from their id[m
[36m@@ -165,7 +170,6 @@[m [mfunc (bb *Biker1) GetNearBikeObjects(bike obj.IMegaBike) (int64, int64, int64) {[m
 	bikeCount := 0[m
 	for _, lootbox := range bb.GetGameState().GetLootBoxes() {[m
 		distance := bb.ComputeDistance(lootbox.GetPosition(), bike.GetPosition())[m
[31m-		//fmt.Printf("distance from bike %v to lootox %v is %v\n", bike.GetID(), lootbox.GetID(), distance)[m
 		if distance <= reachableDistance {[m
 			lootBoxCount += 1[m
 			if lootbox.GetColour() == bb.GetColour() {[m
[1mdiff --git a/internal/clients/team1/loot_allocation.go b/internal/clients/team1/loot_allocation.go[m
[1mindex fa9275a..95402eb 100644[m
[1m--- a/internal/clients/team1/loot_allocation.go[m
[1m+++ b/internal/clients/team1/loot_allocation.go[m
[36m@@ -2,6 +2,8 @@[m [mpackage team1[m
 [m
 import ([m
 	voting "SOMAS2023/internal/common/voting"[m
[32m+[m	[32m"fmt"[m
[32m+[m	[32m"math"[m
 [m
 	"github.com/google/uuid"[m
 )[m
[36m@@ -68,9 +70,9 @@[m [mfunc (bb *Biker1) DecideAllocation() voting.IdVoteMap {[m
 	for agentId := range distribution {[m
 		distribution[agentId] = distribution[agentId] / runningDistribution // Normalise![m
 	}[m
[31m-	// if math.IsNaN(distribution[bb.GetID()]) {[m
[31m-	// 	fmt.Println("Distribution is NaN")[m
[31m-	// }[m
[32m+[m	[32mif math.IsNaN(distribution[bb.GetID()]) {[m
[32m+[m		[32mfmt.Println("Distribution is NaN")[m
[32m+[m	[32m}[m
 	return distribution[m
 }[m
 [m
[1mdiff --git a/internal/clients/team1/message.go b/internal/clients/team1/message.go[m
[1mindex 846dfee..963b41d 100644[m
[1m--- a/internal/clients/team1/message.go[m
[1m+++ b/internal/clients/team1/message.go[m
[36m@@ -15,7 +15,7 @@[m [mfunc (bb *Biker1) VerifySender(sender obj.IBaseBiker) bool {[m
 	// check if sender is on our bike[m
 	if sender.GetBike() == bb.GetBike() {[m
 		// check if sender is trustworthy[m
[31m-		if bb.opinions[sender.GetID()].trust > trustThreshold {[m
[32m+[m		[32mif bb.opinions[sender.GetID()].trust > trustThreshold && bb.opinions[sender.GetID()].opinion > 0.5 {[m
 			return true[m
 		}[m
 	}[m
[36m@@ -28,8 +28,26 @@[m [mfunc (bb *Biker1) HandleKickOffMessage(msg obj.KickoutAgentMessage) {[m
 	verified := bb.VerifySender(sender)[m
 	if verified {[m
 		// slightly penalise view of person who sent message[m
[31m-		penalty := 0.9[m
[31m-		bb.UpdateOpinion(sender.GetID(), penalty)[m
[32m+[m		[32mif msg.AgentId != uuid.Nil {[m
[32m+[m			[32mif msg.Kickout {[m
[32m+[m				[32mif bb.opinions[msg.AgentId].opinion > 0.5 {[m
[32m+[m					[32mpenalty := 0.9[m
[32m+[m					[32mbb.UpdateOpinion(sender.GetID(), penalty)[m
[32m+[m				[32m} else {[m
[32m+[m					[32msameOpinionreward := 1.1[m
[32m+[m					[32mbb.UpdateOpinion(sender.GetID(), sameOpinionreward)[m
[32m+[m				[32m}[m
[32m+[m			[32m} else {[m
[32m+[m				[32mif bb.opinions[msg.AgentId].opinion > 0.5 {[m
[32m+[m					[32msameOpinionreward := 1.1[m
[32m+[m					[32mbb.UpdateOpinion(sender.GetID(), sameOpinionreward)[m
[32m+[m				[32m} else {[m
[32m+[m					[32mpenalty := 0.9[m
[32m+[m					[32mbb.UpdateOpinion(sender.GetID(), penalty)[m
[32m+[m				[32m}[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
[32m+[m
 	}[m
 [m
 }[m
[36m@@ -38,17 +56,38 @@[m [mfunc (bb *Biker1) HandleKickOffMessage(msg obj.KickoutAgentMessage) {[m
 func (bb *Biker1) HandleReputationMessage(msg obj.ReputationOfAgentMessage) {[m
 	sender := msg.GetSender()[m
 	verified := bb.VerifySender(sender)[m
[32m+[m
 	if verified {[m
 		// TODO: SOME FORMULA TO UPDATE OPINION BASED ON REPUTATION given[m
[32m+[m		[32mif msg.AgentId != uuid.Nil {[m
[32m+[m			[32m// Retrieve the struct from the map[m
[32m+[m			[32mopinion, ok := bb.opinions[msg.AgentId][m
[32m+[m			[32mif ok {[m
[32m+[m				[32m// Update the field[m
[32m+[m				[32mopinion.trust += msg.Reputation * reputationScaling[m
[32m+[m				[32mbb.opinions[msg.AgentId] = opinion[m
[32m+[m			[32m}[m
[32m+[m			[32mcurrentReputation := bb.GetReputation()[msg.AgentId] + msg.Reputation[m
[32m+[m			[32mbb.SetReputation(msg.AgentId, currentReputation*reputationScaling)[m
[32m+[m		[32m}[m
 	}[m
[32m+[m	[32m// ask fellow bikers what their reputation of incoming biker is..[m
 }[m
 [m
 // Agent receives a message from another agent to join[m
 func (bb *Biker1) HandleJoiningMessage(msg obj.JoiningAgentMessage) {[m
 	sender := msg.GetSender()[m
[31m-	// check if sender is trustworthy[m
[31m-	if bb.opinions[sender.GetID()].trust > trustThreshold {[m
[31m-		// TODO: some update on opinon maybe???[m
[32m+[m	[32m// different from Verify sender since they are not on our bike[m
[32m+[m	[32mif bb.opinions[sender.GetID()].trust > trustThreshold && bb.opinions[sender.GetID()].opinion > 0.5 {[m
[32m+[m		[32m// check if sender is on our bike[m
[32m+[m		[32mif msg.AgentId != uuid.Nil {[m
[32m+[m			[32magentToJoin := bb.GetAgentFromId(msg.AgentId)[m
[32m+[m			[32mif agentToJoin.GetColour() == bb.GetColour() {[m
[32m+[m				[32msameColourReward := 1.1[m
[32m+[m				[32mbb.UpdateOpinion(sender.GetID(), sameColourReward)[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
[32m+[m
 	}[m
 [m
 }[m
[36m@@ -58,7 +97,12 @@[m [mfunc (bb *Biker1) HandleLootboxMessage(msg obj.LootboxMessage) {[m
 	sender := msg.GetSender()[m
 	verified := bb.VerifySender(sender)[m
 	if verified {[m
[31m-		// TODO: some update on lootbox decision maybe??[m
[32m+[m		[32mif msg.LootboxId != uuid.Nil {[m
[32m+[m			[32mif sender.GetColour() == bb.GetColour() {[m
[32m+[m				[32msameColourReward := 1.2[m
[32m+[m				[32mbb.UpdateOpinion(sender.GetID(), sameColourReward)[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
 	}[m
 }[m
 [m
[36m@@ -68,6 +112,7 @@[m [mfunc (bb *Biker1) HandleGovernanceMessage(msg obj.GovernanceMessage) {[m
 	verified := bb.VerifySender(sender)[m
 	if verified {[m
 		// TODO: some update on governance decision maybe??[m
[32m+[m
 	}[m
 }[m
 [m
[36m@@ -85,8 +130,9 @@[m [mfunc (bb *Biker1) HandleForcesMessage(msg obj.ForcesMessage) {[m
 				//set our opinion of them to 0, should be kicked in next loop[m
 				bb.UpdateOpinion(sender.GetID(), 0)[m
 			}[m
[32m+[m			[32m// Lower opinion if they are not pedalling[m
 			if msg.AgentForces.Pedal == 0 {[m
[31m-				bb.UpdateOpinion(sender.GetID(), bb.opinions[sender.GetID()].opinion*0.9)[m
[32m+[m				[32mbb.UpdateOpinion(sender.GetID(), 0.9)[m
 			}[m
 		}[m
 		return[m
[36m@@ -125,18 +171,25 @@[m [mfunc (bb *Biker1) CreateKickOffMessage() obj.KickoutAgentMessage {[m
 [m
 func (bb *Biker1) CreateReputationMessage() obj.ReputationOfAgentMessage {[m
 	// Tell the truth (for now)[m
[31m-	// TODO: receipients = fellowBikers that we trust?[m
[32m+[m	[32mopinions, ok := bb.opinions[bb.GetID()][m
[32m+[m	[32mreputation := opinions.opinion[m
[32m+[m	[32mif !ok {[m
[32m+[m		[32mreputation = 0.0[m
[32m+[m	[32m} else {[m
[32m+[m		[32mreputation = bb.opinions[bb.GetID()].opinion[m
[32m+[m	[32m}[m
[32m+[m
 	return obj.ReputationOfAgentMessage{[m
 		BaseMessage: messaging.CreateMessage[obj.IBaseBiker](bb, bb.GetTrustedRecepients()),[m
 		AgentId:     uuid.Nil,[m
[31m-		Reputation:  1.0,[m
[32m+[m		[32mReputation:  reputation,[m
 	}[m
 }[m
 [m
 func (bb *Biker1) CreateJoiningMessage() obj.JoiningAgentMessage {[m
 	// Tell the truth (for now)[m
 	// receipients = fellowBikers[m
[31m-	biketoJoin := bb.ChangeBike()[m
[32m+[m	[32mbiketoJoin := bb.PickBestBike()[m
 	gs := bb.GetGameState()[m
 	joiningBike := gs.GetMegaBikes()[biketoJoin][m
 	return obj.JoiningAgentMessage{[m
[36m@@ -179,8 +232,31 @@[m [mfunc (bb *Biker1) CreateGoverenceMessage() obj.GovernanceMessage {[m
 // Agent sending messages to other agents[m
 func (bb *Biker1) GetAllMessages([]obj.IBaseBiker) []messaging.IMessage[obj.IBaseBiker] {[m
 	var sendKickMessage, sendReputationMessage, sendJoiningMessage, sendLootboxMessage, sendGovernanceMessage bool[m
[32m+[m	[32msendKickMessage = false[m
[32m+[m	[32msendReputationMessage = false[m
[32m+[m	[32msendJoiningMessage = false[m
[32m+[m	[32msendLootboxMessage = false[m
[32m+[m	[32msendGovernanceMessage = false[m
 [m
 	// TODO: add logic to decide which messages to send and when[m
[32m+[m	[32mif bb.GetBike() == uuid.Nil && bb.GetBikeStatus() == false {[m
[32m+[m		[32msendGovernanceMessage = true[m
[32m+[m		[32msendJoiningMessage = false[m
[32m+[m	[32m} else if bb.GetBike() == uuid.Nil {[m
[32m+[m		[32msendJoiningMessage = true[m
[32m+[m	[32m} else {[m
[32m+[m		[32mfor _, agent := range bb.GetFellowBikers() {[m
[32m+[m			[32mif bb.opinions[agent.GetID()].opinion < kickThreshold {[m
[32m+[m				[32msendKickMessage = true[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mif (bb.opinions[agent.GetID()].trust > trustThreshold) && (bb.opinions[agent.GetID()].opinion > 0.5) {[m
[32m+[m				[32msendGovernanceMessage = true[m
[32m+[m				[32msendLootboxMessage = true[m
[32m+[m				[32m// Never send reputation message			}[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
 [m
 	var messageList []messaging.IMessage[obj.IBaseBiker][m
 	if sendKickMessage {[m
[1mdiff --git a/internal/clients/team1/opinion.go b/internal/clients/team1/opinion.go[m
[1mindex 42d1bc3..01ac028 100644[m
[1m--- a/internal/clients/team1/opinion.go[m
[1m+++ b/internal/clients/team1/opinion.go[m
[36m@@ -4,49 +4,21 @@[m [mpackage team1[m
 [m
 import ([m
 	obj "SOMAS2023/internal/common/objects"[m
[31m-	utils "SOMAS2023/internal/common/utils"[m
 	"math"[m
 [m
 	"github.com/google/uuid"[m
 )[m
 [m
 type Opinion struct {[m
[31m-	effort          float64[m
[31m-	trust           float64[m
[31m-	fairness        float64[m
[31m-	relativeSuccess float64[m
[31m-	// forgiveness float64[m
[32m+[m	[32meffort   float64[m
[32m+[m	[32mtrust    float64[m
[32m+[m	[32mfairness float64[m
[32m+[m	[32m// relativeSuccess float64[m
 	opinion float64 // cumulative result of all the above[m
 }[m
 [m
 // -----------------OPINION FUNCTIONS------------------[m
 [m
[31m-func (bb *Biker1) UpdateEffort(agentID uuid.UUID) {[m
[31m-	agent := bb.GetAgentFromId(agentID)[m
[31m-	fellowBikers := bb.GetFellowBikers()[m
[31m-	totalPedalForce := 0.0[m
[31m-	for _, agent := range fellowBikers {[m
[31m-		totalPedalForce = totalPedalForce + agent.GetForces().Pedal[m
[31m-	}[m
[31m-	avgForce := totalPedalForce / float64(len(fellowBikers))[m
[31m-	//effort expectation is scaled by their energy level -- should it be? (*agent.GetEnergyLevel())[m
[31m-	finalEffort := bb.opinions[agent.GetID()].effort + (agent.GetForces().Pedal-avgForce)*effortScaling[m
[31m-[m
[31m-	if finalEffort > 1 {[m
[31m-		finalEffort = 1[m
[31m-	}[m
[31m-	if finalEffort < 0 {[m
[31m-		finalEffort = 0[m
[31m-	}[m
[31m-	newOpinion := Opinion{[m
[31m-		effort:   finalEffort,[m
[31m-		fairness: bb.opinions[agentID].fairness,[m
[31m-		trust:    bb.opinions[agentID].trust,[m
[31m-		opinion:  bb.opinions[agentID].opinion,[m
[31m-	}[m
[31m-	bb.opinions[agent.GetID()] = newOpinion[m
[31m-}[m
[31m-[m
 func (bb *Biker1) UpdateTrust(agentID uuid.UUID) {[m
 	id := agentID[m
 	agent := bb.GetAgentFromId(id)[m
[36m@@ -70,17 +42,19 @@[m [mfunc (bb *Biker1) UpdateTrust(agentID uuid.UUID) {[m
 		}[m
 	}[m
 [m
[32m+[m	[32m// We update the trust value too of the agent from direct experience from messaging session[m
[32m+[m
 	if finalTrust > 1 {[m
 		finalTrust = 1[m
 	} else if finalTrust < 0 {[m
 		finalTrust = 0[m
 	}[m
 	newOpinion := Opinion{[m
[31m-		effort:          bb.opinions[id].effort,[m
[31m-		fairness:        bb.opinions[id].fairness,[m
[31m-		trust:           finalTrust,[m
[31m-		relativeSuccess: bb.opinions[id].relativeSuccess,[m
[31m-		opinion:         bb.opinions[id].opinion,[m
[32m+[m		[32meffort:   bb.opinions[id].effort,[m
[32m+[m		[32mfairness: bb.opinions[id].fairness,[m
[32m+[m		[32mtrust:    finalTrust,[m
[32m+[m		[32m// relativeSuccess: bb.opinions[id].relativeSuccess,[m
[32m+[m		[32mopinion: bb.opinions[id].opinion,[m
 	}[m
 	bb.opinions[id] = newOpinion[m
 }[m
[36m@@ -91,7 +65,6 @@[m [mfunc (bb *Biker1) UpdateFairness(agentID uuid.UUID) {[m
 	agent := bb.GetAgentFromId(agentID)[m
 	energyChange := agent.GetEnergyLevel() - bb.prevEnergy[agentID] //how much of lootx distribution they got[m
 	finalFairness := bb.opinions[agent.GetID()].fairness[m
[31m-[m
 	if energyChange-helpfulAllocation[agentID] > 0 {[m
 		//they have more than they should have fairly got[m
 		finalFairness -= (energyChange - helpfulAllocation[agentID]) * fairnessScaling[m
[36m@@ -106,50 +79,33 @@[m [mfunc (bb *Biker1) UpdateFairness(agentID uuid.UUID) {[m
 	}[m
 [m
 	newOpinion := Opinion{[m
[31m-		effort:          bb.opinions[agentID].effort,[m
[31m-		fairness:        finalFairness,[m
[31m-		trust:           bb.opinions[agentID].trust,[m
[31m-		relativeSuccess: bb.opinions[agentID].relativeSuccess,[m
[31m-		opinion:         bb.opinions[agentID].opinion,[m
[31m-	}[m
[31m-	bb.opinions[agentID] = newOpinion[m
[31m-}[m
[31m-[m
[31m-func (bb *Biker1) UpdateRelativeSuccess(agentID uuid.UUID) {[m
[31m-	relativeSuccess := bb.GetRelativeSuccess(bb.GetID(), agentID)[m
[31m-	finalRelativeSuccess := bb.opinions[agentID].relativeSuccess + (relativeSuccess-bb.opinions[agentID].relativeSuccess)*relativeSuccessScaling[m
[31m-	if finalRelativeSuccess > 1 {[m
[31m-		finalRelativeSuccess = 1[m
[31m-	}[m
[31m-	if finalRelativeSuccess < 0 {[m
[31m-		finalRelativeSuccess = 0[m
[31m-	}[m
[31m-	newOpinion := Opinion{[m
[31m-		effort:          bb.opinions[agentID].effort,[m
[31m-		fairness:        bb.opinions[agentID].fairness,[m
[31m-		trust:           bb.opinions[agentID].trust,[m
[31m-		relativeSuccess: finalRelativeSuccess,[m
[31m-		opinion:         bb.opinions[agentID].opinion,[m
[32m+[m		[32meffort:   bb.opinions[agentID].effort,[m
[32m+[m		[32mfairness: finalFairness,[m
[32m+[m		[32mtrust:    bb.opinions[agentID].trust,[m
[32m+[m		[32m// relativeSuccess: bb.opinions[agentID].relativeSuccess,[m
[32m+[m		[32mopinion: bb.opinions[agentID].opinion,[m
 	}[m
 	bb.opinions[agentID] = newOpinion[m
 }[m
 [m
 // how well does agent 1 like agent 2 according to objective metrics[m
[31m-func (bb *Biker1) GetRelativeSuccess(id1 uuid.UUID, id2 uuid.UUID) float64 {[m
[32m+[m[32mfunc (bb *Biker1) GetRelativeSuccess(id1 uuid.UUID, id2 uuid.UUID, all_agents []obj.IBaseBiker) float64 {[m
 	agent1 := bb.GetAgentFromId(id1)[m
 	agent2 := bb.GetAgentFromId(id2)[m
 	relativeSuccess := 0.0[m
[32m+[m	[32m// Colour comparison[m
 	if agent1.GetColour() == agent2.GetColour() {[m
 		relativeSuccess = relativeSuccess + colorOpinionConstant[m
 	}[m
[32m+[m	[32m//Energy comparison[m
 	relativeSuccess = relativeSuccess + (agent1.GetEnergyLevel() - agent2.GetEnergyLevel())[m
[31m-	all_agents := bb.GetAllAgents()[m
 	maxpoints := 0[m
 	for _, agent := range all_agents {[m
 		if agent.GetPoints() > maxpoints {[m
 			maxpoints = agent.GetPoints()[m
 		}[m
 	}[m
[32m+[m	[32m// Points comparison[m
 	if maxpoints != 0 {[m
 		relativeSuccess = relativeSuccess + float64((agent1.GetPoints()-agent2.GetPoints())/maxpoints)[m
 	}[m
[36m@@ -162,21 +118,22 @@[m [mfunc (bb *Biker1) UpdateOpinion(id uuid.UUID, multiplier float64) {[m
 	if !ok {[m
 		//if we have no data on an agent, initialise to neutral[m
 		newOpinion := Opinion{[m
[31m-			effort:          0.5,[m
[31m-			trust:           0.5,[m
[31m-			fairness:        0.5,[m
[31m-			relativeSuccess: 0.5,[m
[31m-			opinion:         0.5,[m
[32m+[m			[32meffort:   0.5,[m
[32m+[m			[32mtrust:    0.5,[m
[32m+[m			[32mfairness: 0.5,[m
[32m+[m			[32m// relativeSuccess: 0.5,[m
[32m+[m			[32mopinion: 0.5,[m
 		}[m
 		bb.opinions[id] = newOpinion[m
 	}[m
 [m
 	newOpinion := Opinion{[m
[31m-		effort:          bb.opinions[id].effort,[m
[31m-		trust:           bb.opinions[id].trust,[m
[31m-		fairness:        bb.opinions[id].fairness,[m
[31m-		relativeSuccess: bb.opinions[id].relativeSuccess,[m
[31m-		opinion:         ((bb.opinions[id].trust*trustconstant + bb.opinions[id].effort*effortConstant + bb.opinions[id].fairness*fairnessConstant) / (trustconstant + effortConstant + fairnessConstant)) * multiplier,[m
[32m+[m		[32meffort:   bb.opinions[id].effort,[m
[32m+[m		[32mtrust:    bb.opinions[id].trust,[m
[32m+[m		[32mfairness: bb.opinions[id].fairness,[m
[32m+[m		[32m// relativeSuccess: bb.opinions[id].relativeSuccess,[m
[32m+[m		[32mopinion: ((bb.opinions[id].trust*trustconstant + bb.opinions[id].effort*effortConstant +[m
[32m+[m			[32mbb.opinions[id].fairness*fairnessConstant) / (trustconstant + effortConstant + fairnessConstant)) * multiplier,[m
 	}[m
 [m
 	if newOpinion.opinion > 1 {[m
[36m@@ -189,17 +146,17 @@[m [mfunc (bb *Biker1) UpdateOpinion(id uuid.UUID, multiplier float64) {[m
 }[m
 [m
 func (bb *Biker1) setOpinions() map[uuid.UUID]Opinion {[m
[31m-	if bb.opinions == nil {[m
[31m-		bb.opinions = make(map[uuid.UUID]Opinion)[m
[31m-		for _, agent := range bb.GetAllAgents() {[m
[31m-			agentId := agent.GetID()[m
[32m+[m	[32mfor _, agent := range bb.GetAllAgents() {[m
[32m+[m		[32magentId := agent.GetID()[m
[32m+[m		[32m_, ok := bb.opinions[agentId][m
[32m+[m		[32mif !ok {[m
 			//if we have no data on an agent, initialise to neutral[m
 			newOpinion := Opinion{[m
[31m-				effort:          0.5,[m
[31m-				trust:           0.5,[m
[31m-				fairness:        0.5,[m
[31m-				relativeSuccess: 0.5,[m
[31m-				opinion:         0.5,[m
[32m+[m				[32meffort:   0.5,[m
[32m+[m				[32mtrust:    0.5,[m
[32m+[m				[32mfairness: 0.5,[m
[32m+[m				[32m// relativeSuccess: 0.5,[m
[32m+[m				[32mopinion: 0.5,[m
 			}[m
 			bb.opinions[agentId] = newOpinion[m
 		}[m
[36m@@ -208,19 +165,27 @@[m [mfunc (bb *Biker1) setOpinions() map[uuid.UUID]Opinion {[m
 }[m
 [m
 // infer our reputation from the average relative success of agents in the current context[m
[31m-func (bb *Biker1) DetermineOurReputation() float64 {[m
[32m+[m[32mfunc (bb *Biker1) DetermineOurAverageReputation() float64 {[m
 	var agentsInContext []obj.IBaseBiker[m
[32m+[m	[32mvar numberOnBike float64[m
 	if bb.GetBike() == uuid.Nil {[m
 		agentsInContext = bb.GetAllAgents()[m
 	} else {[m
 		agentsInContext = bb.GetFellowBikers()[m
 	}[m
[32m+[m	[32mif len(agentsInContext) == 0 {[m
[32m+[m		[32mnumberOnBike = 1[m
[32m+[m	[32m} else {[m
[32m+[m		[32mnumberOnBike = float64(len(agentsInContext))[m
[32m+[m	[32m}[m
 [m
 	reputation := 0.0[m
 	for _, agent := range agentsInContext {[m
[31m-		reputation = reputation + bb.GetRelativeSuccess(bb.GetID(), agent.GetID())[m
[32m+[m		[32m// bb.UpdateRelativeSuccess(agent.GetID(), agentsInContext)[m
[32m+[m		[32m// fmt.Printf("Agent %v relative success: %v\n", agent.GetID(), bb.GetRelativeSuccess(bb.GetID(), agent.GetID(), agentsInContext))[m
[32m+[m		[32mreputation = reputation + bb.GetRelativeSuccess(bb.GetID(), agent.GetID(), agentsInContext)[m
 	}[m
[31m-	reputation = reputation / float64(len(agentsInContext))[m
[32m+[m	[32mreputation = reputation / numberOnBike[m
 	return reputation[m
 }[m
 [m
[36m@@ -234,11 +199,11 @@[m [mfunc (bb *Biker1) UpdateAllAgentsOpinions(agents_to_update []obj.IBaseBiker) {[m
 			agentId := agent.GetID()[m
 			//if we have no data on an agent, initialise to neutral[m
 			newOpinion := Opinion{[m
[31m-				effort:          0.5,[m
[31m-				trust:           0.5,[m
[31m-				fairness:        0.5,[m
[31m-				relativeSuccess: 0.5,[m
[31m-				opinion:         0.5,[m
[32m+[m				[32meffort:   0.5,[m
[32m+[m				[32mtrust:    0.5,[m
[32m+[m				[32mfairness: 0.5,[m
[32m+[m				[32m// relativeSuccess: 0.5,[m
[32m+[m				[32mopinion: 0.5,[m
 			}[m
 			bb.opinions[agentId] = newOpinion[m
 		}[m
[36m@@ -249,26 +214,18 @@[m [mfunc (bb *Biker1) UpdateAllAgentsOpinions(agents_to_update []obj.IBaseBiker) {[m
 [m
 func (bb *Biker1) UpdateAllAgentsEffort() {[m
 	fellowBikers := bb.GetFellowBikers()[m
[31m-	bikeId := bb.GetBike()[m
[31m-	gs := bb.GetGameState()[m
[31m-	totalMass := utils.MassBike + float64(len(fellowBikers))*utils.MassBiker[m
[31m-	velocity := gs.GetMegaBikes()[bikeId].GetPhysicalState().Velocity[m
[31m-	drag_force := utils.DragCoefficient * math.Pow(velocity, 2)[m
[31m-	acceleration := gs.GetMegaBikes()[bikeId].GetPhysicalState().Acceleration[m
[31m-	total_force := acceleration * totalMass[m
[31m-[m
[31m-	//resultant =[m
[31m-[m
[31m-	// bike_force := utils.MassBike * acceleration[m
[31m-	// fmt.Printf("Bike force: %v\n", bike_force)[m
[31m-	//resultant = force - drag[m
[31m-	//force = mass*unknown acceleration?[m
[31m-	//actual acceleration is calculated from (totalpedalforce - CalcDrag(v)) / m[m
[31m-	//resultant = mass*actual acceleration[m
[31m-	totalPedalForce := total_force + drag_force[m
[31m-[m
[31m-	// Calculate force pedalled by everyone else[m
[31m-	remainingForce := totalPedalForce - bb.getPedalForce()[m
[32m+[m
[32m+[m	[32m// totalPedalForce := total_force + drag_force[m
[32m+[m
[32m+[m	[32mfellowBikersExpendedEnergy := make(map[uuid.UUID]float64)[m
[32m+[m	[32mtotalExpendedEnergy := 0.0[m
[32m+[m	[32mfor _, agent := range fellowBikers {[m
[32m+[m		[32mAgentExpendedEnergy := (bb.prevEnergy[agent.GetID()] - agent.GetEnergyLevel())[m
[32m+[m		[32mfellowBikersExpendedEnergy[agent.GetID()] = AgentExpendedEnergy[m
[32m+[m		[32mtotalExpendedEnergy += AgentExpendedEnergy[m
[32m+[m	[32m}[m
[32m+[m	[32mOurExpendedEnergy := bb.prevEnergy[bb.GetID()] - bb.GetEnergyLevel()[m
[32m+[m
 	effortProbability := make(map[uuid.UUID]float64) //probability that they are exc[m
 	totalEffort := 0.0[m
 	for _, agent := range fellowBikers {[m
[36m@@ -279,11 +236,11 @@[m [mfunc (bb *Biker1) UpdateAllAgentsEffort() {[m
 			agentId := agent.GetID()[m
 			//if we have no data on an agent, initialise to neutral[m
 			newOpinion := Opinion{[m
[31m-				effort:          0.5,[m
[31m-				trust:           0.5,[m
[31m-				fairness:        0.5,[m
[31m-				relativeSuccess: 0.5,[m
[31m-				opinion:         0.5,[m
[32m+[m				[32meffort:   0.5,[m
[32m+[m				[32mtrust:    0.5,[m
[32m+[m				[32mfairness: 0.5,[m
[32m+[m				[32m// relativeSuccess: 0.5,[m
[32m+[m				[32mopinion: 0.5,[m
 			}[m
 			bb.opinions[agentId] = newOpinion[m
 		}[m
[36m@@ -292,7 +249,7 @@[m [mfunc (bb *Biker1) UpdateAllAgentsEffort() {[m
 		if agent.GetColour() != bb.recentDecidedColour {[m
 			//probability should be high[m
 			//for now set to 0.5 but later change based on how close the lootbox is to their colour lootbox[m
[31m-			colourProb += 0.3[m
[32m+[m			[32mcolourProb += 0.35[m
 		}[m
 		energyProb := 1 - agent.GetEnergyLevel()[m
 		//Will add weightings to this so that energy probability has a lower weighting than difference in colour for example[m
[36m@@ -305,11 +262,11 @@[m [mfunc (bb *Biker1) UpdateAllAgentsEffort() {[m
 	for agentId := range effortProbability {[m
 		//normalise effort probabilities[m
 		effortProbability[agentId] /= totalEffort[m
[31m-		effortProbability[agentId] *= remainingForce[m
[32m+[m		[32meffortProbability[agentId] *= totalExpendedEnergy[m
 		agent := bb.GetAgentFromId(agentId)[m
[31m-[m
[31m-		//effort expectation is scaled by their energy and compare to our effort[m
[31m-		finalEffort := bb.opinions[agentId].effort + (effortProbability[agentId]-bb.getPedalForce())*effortScaling[m
[32m+[m		[32m// Effort = Current effort + trust * effort probability * (fellow biker's expended energy - our expended energy)[m
[32m+[m		[32mfinalEffort := bb.opinions[agentId].effort + bb.opinions[agentId].trust*effortProbability[agentId]*(fellowBikersExpendedEnergy[agentId]-OurExpendedEnergy)*effortScaling[m
[32m+[m		[32m// fmt.Printf("Final effort: %v\n", finalEffort)[m
 [m
 		if finalEffort > 1 {[m
 			finalEffort = 1[m
[36m@@ -318,11 +275,11 @@[m [mfunc (bb *Biker1) UpdateAllAgentsEffort() {[m
 			finalEffort = 0[m
 		}[m
 		newOpinion := Opinion{[m
[31m-			effort:          finalEffort,[m
[31m-			fairness:        bb.opinions[agentId].fairness,[m
[31m-			trust:           bb.opinions[agentId].trust,[m
[31m-			relativeSuccess: bb.opinions[agentId].relativeSuccess,[m
[31m-			opinion:         bb.opinions[agentId].opinion,[m
[32m+[m			[32meffort:   finalEffort,[m
[32m+[m			[32mfairness: bb.opinions[agentId].fairness,[m
[32m+[m			[32mtrust:    bb.opinions[agentId].trust,[m
[32m+[m			[32m// relativeSuccess: bb.opinions[agentId].relativeSuccess,[m
[32m+[m			[32mopinion: bb.opinions[agentId].opinion,[m
 		}[m
 		bb.opinions[agent.GetID()] = newOpinion[m
 	}[m
[36m@@ -339,11 +296,11 @@[m [mfunc (bb *Biker1) UpdateAllAgentsTrust(agents_to_update []obj.IBaseBiker) {[m
 			agentId := agent.GetID()[m
 			//if we have no data on an agent, initialise to neutral[m
 			newOpinion := Opinion{[m
[31m-				effort:          0.5,[m
[31m-				trust:           0.5,[m
[31m-				fairness:        0.5,[m
[31m-				relativeSuccess: 0.5,[m
[31m-				opinion:         0.5,[m
[32m+[m				[32meffort:   0.5,[m
[32m+[m				[32mtrust:    0.5,[m
[32m+[m				[32mfairness: 0.5,[m
[32m+[m				[32m// relativeSuccess: 0.5,[m
[32m+[m				[32mopinion: 0.5,[m
 			}[m
 			bb.opinions[agentId] = newOpinion[m
 		}[m
[36m@@ -361,11 +318,11 @@[m [mfunc (bb *Biker1) UpdateAllAgentsFairness(agents_to_update []obj.IBaseBiker) {[m
 			agentId := agent.GetID()[m
 			//if we have no data on an agent, initialise to neutral[m
 			newOpinion := Opinion{[m
[31m-				effort:          0.5,[m
[31m-				trust:           0.5,[m
[31m-				fairness:        0.5,[m
[31m-				relativeSuccess: 0.5,[m
[31m-				opinion:         0.5,[m
[32m+[m				[32meffort:   0.5,[m
[32m+[m				[32mtrust:    0.5,[m
[32m+[m				[32mfairness: 0.5,[m
[32m+[m				[32m// relativeSuccess: 0.5,[m
[32m+[m				[32mopinion: 0.5,[m
 			}[m
 			bb.opinions[agentId] = newOpinion[m
 		}[m
[36m@@ -382,26 +339,4 @@[m [mfunc (bb *Biker1) UpdateAllAgentsFairness(agents_to_update []obj.IBaseBiker) {[m
 	}[m
 }[m
 [m
[31m-func (bb *Biker1) UpdateAllAgentsRelativeSuccess(agents_to_update []obj.IBaseBiker) {[m
[31m-	bb.setOpinions()[m
[31m-	for _, agent := range agents_to_update {[m
[31m-		id := agent.GetID()[m
[31m-		_, ok := bb.opinions[id][m
[31m-[m
[31m-		if !ok {[m
[31m-			agentId := agent.GetID()[m
[31m-			//if we have no data on an agent, initialise to neutral[m
[31m-			newOpinion := Opinion{[m
[31m-				effort:          0.5,[m
[31m-				trust:           0.5,[m
[31m-				fairness:        0.5,[m
[31m-				relativeSuccess: 0.5,[m
[31m-				opinion:         0.5,[m
[31m-			}[m
[31m-			bb.opinions[agentId] = newOpinion[m
[31m-		}[m
[31m-		bb.UpdateRelativeSuccess(id)[m
[31m-	}[m
[31m-}[m
[31m-[m
 // ----------------END OF OPINION FUNCTIONS--------------[m
[1mdiff --git a/internal/clients/team1/social.go b/internal/clients/team1/social.go[m
[1mindex 8c16d46..4c64d37 100644[m
[1m--- a/internal/clients/team1/social.go[m
[1m+++ b/internal/clients/team1/social.go[m
[36m@@ -8,13 +8,13 @@[m [mimport ([m
 [m
 // ---------------------SOCIAL FUNCTIONS------------------------[m
 // get reputation value of all other agents[m
[31m-func (bb *Biker1) GetReputation() map[uuid.UUID]float64 {[m
[31m-	reputation := map[uuid.UUID]float64{}[m
[31m-	for agent, opinion := range bb.opinions {[m
[31m-		reputation[agent] = opinion.opinion[m
[31m-	}[m
[31m-	return reputation[m
[31m-}[m
[32m+[m[32m// func (bb *Biker1) GetReputation() map[uuid.UUID]float64 {[m
[32m+[m[32m// 	reputation := map[uuid.UUID]float64{}[m
[32m+[m[32m// 	for agent, opinion := range bb.opinions {[m
[32m+[m[32m// 		reputation[agent] = opinion.opinion[m
[32m+[m[32m// 	}[m
[32m+[m[32m// 	return reputation[m
[32m+[m[32m// }[m
 [m
 // query for reputation value of specific agent with UUID[m
 func (bb *Biker1) QueryReputation(agent uuid.UUID) float64 {[m
[36m@@ -26,14 +26,10 @@[m [mfunc (bb *Biker1) QueryReputation(agent uuid.UUID) float64 {[m
 	}[m
 }[m
 [m
[31m-// set reputation value of specific agent with UUID[m
[31m-func (bb *Biker1) SetReputation(agent uuid.UUID, reputation float64) {[m
[31m-	bb.opinions[agent] = Opinion{[m
[31m-		effort:   bb.opinions[agent].effort,[m
[31m-		trust:    bb.opinions[agent].trust,[m
[31m-		fairness: bb.opinions[agent].fairness,[m
[31m-		opinion:  reputation,[m
[31m-	}[m
[31m-}[m
[32m+[m[32m// // set reputation value of specific agent with UUID[m
[32m+[m[32m// func (bb *Biker1) SetReputation(agent uuid.UUID, reputation float64) {[m
[32m+[m[32m// 	//bb.reputation[agent] += reputation[m
[32m+[m
[32m+[m[32m// }[m
 [m
 //---------------------END OF SOCIAL FUNCTIONS------------------------[m
[1mdiff --git a/internal/common/objects/BaseBiker.go b/internal/common/objects/BaseBiker.go[m
[1mindex 2320656..fee01dc 100644[m
[1m--- a/internal/common/objects/BaseBiker.go[m
[1m+++ b/internal/common/objects/BaseBiker.go[m
[36m@@ -335,7 +335,7 @@[m [mfunc (bb *BaseBiker) DecideJoining(pendingAgents []uuid.UUID) map[uuid.UUID]bool[m
 [m
 func (bb *BaseBiker) DecideGovernance() utils.Governance {[m
 	// Change behaviour here to return different governance[m
[31m-	return utils.Democracy[m
[32m+[m	[32mreturn utils.Leadership[m
 }[m
 [m
 func (bb *BaseBiker) ResetPoints() {[m
[1mdiff --git a/internal/server/SimLoop.go b/internal/server/SimLoop.go[m
[1mindex 3b71fa7..a202cc8 100644[m
[1m--- a/internal/server/SimLoop.go[m
[1m+++ b/internal/server/SimLoop.go[m
[36m@@ -5,6 +5,7 @@[m [mimport ([m
 	"SOMAS2023/internal/common/utils"[m
 	"SOMAS2023/internal/common/voting"[m
 	"cmp"[m
[32m+[m	[32m"fmt"[m
 	"math"[m
 	"slices"[m
 [m
[36m@@ -163,14 +164,14 @@[m [mfunc (s *Server) Start() {[m
 	gameStates := make([][]GameStateDump, 0, s.GetIterations())[m
 	s.deadAgents = make(map[uuid.UUID]objects.IBaseBiker)[m
 	for i := 0; i < s.GetIterations(); i++ {[m
[31m-		// fmt.Printf("Game Loop %d running... \n \n", i)[m
[32m+[m		[32mfmt.Printf("Game Loop %d running... \n \n", i)[m
 		// fmt.Printf("Main game loop running...\n\n")[m
 		gameStates = append(gameStates, s.RunSimLoop(utils.RoundIterations))[m
 		// fmt.Printf("\nMain game loop finished.\n\n")[m
 		// fmt.Printf("Messaging session started...\n\n")[m
 		s.RunMessagingSession()[m
 		// fmt.Printf("\nMessaging session completed\n\n")[m
[31m-		// fmt.Printf("Game Loop %d completed.\n", i)[m
[32m+[m		[32mfmt.Printf("Game Loop %d completed.\n", i)[m
 	}[m
 	s.outputResults(gameStates)[m
 }[m
[1mdiff --git a/internal/server/Spawner.go b/internal/server/Spawner.go[m
[1mindex 88605a8..af21e8c 100644[m
[1m--- a/internal/server/Spawner.go[m
[1m+++ b/internal/server/Spawner.go[m
[36m@@ -1,14 +1,6 @@[m
 package server[m
 [m
 import ([m
[31m-	"SOMAS2023/internal/clients/team1"[m
[31m-	"SOMAS2023/internal/clients/team2"[m
[31m-	"SOMAS2023/internal/clients/team3"[m
[31m-	"SOMAS2023/internal/clients/team4"[m
[31m-	team5Agent "SOMAS2023/internal/clients/team5"[m
[31m-	"SOMAS2023/internal/clients/team6"[m
[31m-	"SOMAS2023/internal/clients/team7"[m
[31m-	"SOMAS2023/internal/clients/team8"[m
 	"SOMAS2023/internal/common/objects"[m
 	"SOMAS2023/internal/common/utils"[m
 [m
[36m@@ -19,14 +11,15 @@[m [mimport ([m
 type AgentInitFunction func(baseBiker *objects.BaseBiker) objects.IBaseBiker[m
 [m
 var AgentInitFunctions = []AgentInitFunction{[m
[31m-	team1.GetBiker1,         // Team 1[m
[31m-	team2.GetBiker,          // Team 2[m
[31m-	team3.GetT3Agent,        // Team 3[m
[31m-	team4.GetBiker4,         // Team 4[m
[31m-	team5Agent.GetBiker,     // Team 5[m
[31m-	team6.InitialiseBiker6,  // Team 6[m
[31m-	team7.GetTeamSevenBiker, // Team 7[m
[31m-	team8.GetIBaseBiker,     // Team 8[m
[32m+[m	[32m// team1.GetBiker1,         // Team 1[m
[32m+[m	[32m// team2.GetBiker,          // Team 2[m
[32m+[m	[32m// team3.GetT3Agent,        // Team 3[m
[32m+[m	[32m// team4.GetBiker4,         // Team 4[m
[32m+[m	[32m// team5Agent.GetBiker,     // Team 5[m
[32m+[m	[32m// team6.InitialiseBiker6,  // Team 6[m
[32m+[m	[32m// team7.GetTeamSevenBiker, // Team 7[m
[32m+[m	[32m// team8.GetIBaseBiker,     // Team 8[m
[32m+[m	[32mnil,[m
 }[m
 [m
 func GetAgentGenerators() []baseserver.AgentGeneratorCountPair[objects.IBaseBiker] {[m
